From 1b048e3178cc1dab543fdd8d1dd6e021945c8209 Mon Sep 17 00:00:00 2001
From: Bala Bosch <bala.bosch@gmail.com>
Date: Wed, 23 Sep 2015 12:36:06 -0400
Subject: [PATCH] Patched workbench moderation to allow it to work with
 pathauto alias generation.

---
 .../workbench_path_revision.module                 | 77 ++++++++++++++++++++++
 1 file changed, 77 insertions(+)

diff --git a/sites/all/modules/contrib/workbench_path_revision/workbench_path_revision.module b/sites/all/modules/contrib/workbench_path_revision/workbench_path_revision.module
index abb0396..f7cb841 100644
--- a/sites/all/modules/contrib/workbench_path_revision/workbench_path_revision.module
+++ b/sites/all/modules/contrib/workbench_path_revision/workbench_path_revision.module
@@ -155,6 +155,9 @@ function workbench_path_revision_node_update($node) {
     foreach ($node->workbench_path_revision as $path_revision) {
       $path_revision['nid'] = $node->nid;
       $path_revision['vid'] = $node->vid;
+      if (!empty($path_revision['pathauto'])) {
+        $path_revision['alias'] = _workbench_path_revision_generate_path($node);
+      }
       // Null aliases will break when saving,
       // so we can safely convert them to empty strings.
       if (empty($path_revision['alias'])) {
@@ -166,6 +169,80 @@ function workbench_path_revision_node_update($node) {
 }
 
 /**
+ * Helper function to generate a path alias without actually creating it in DB.
+ *
+ * @see workbench_path_revision_node_update()
+ * @see pathauto_create_alias()
+ */
+function _workbench_path_revision_generate_path(stdClass $node) {
+  $module = 'node';
+  // @todo Does this need to allow 'insert' or 'bulkupdate'?
+  $op = 'update';
+  $uri = entity_uri('node', $node);
+  $source = $uri['path'];
+  $data = array('node' => $node);
+  $type = $node->type;
+  $language = pathauto_entity_language('node', $node);
+
+  $pattern = pathauto_pattern_load_by_entity($module, $type, $language);
+  if (empty($pattern)) {
+    // No pattern? Do nothing (otherwise we may blow away existing aliases...)
+    return;
+  }
+
+  module_load_include('inc', 'pathauto');
+
+  // Replace any tokens in the pattern. Uses callback option to clean replacements. No sanitization.
+  $alias = token_replace($pattern, $data, array(
+    'sanitize' => FALSE,
+    'clear' => TRUE,
+    'callback' => 'pathauto_clean_token_values',
+    'language' => (object) array('language' => $language),
+    'pathauto' => TRUE,
+  ));
+
+  // Check if the token replacement has not actually replaced any values. If
+  // that is the case, then stop because we should not generate an alias.
+  // @see token_scan()
+  $pattern_tokens_removed = preg_replace('/\[[^\s\]:]*:[^\s\]]*\]/', '', $pattern);
+  if ($alias === $pattern_tokens_removed) {
+    return '';
+  }
+
+  $alias = pathauto_clean_alias($alias);
+
+  // Allow other modules to alter the alias.
+  $context = array(
+    'module' => $module,
+    'op' => $op,
+    'source' => &$source,
+    'data' => $data,
+    'type' => $type,
+    'language' => &$language,
+    'pattern' => $pattern,
+  );
+  drupal_alter('pathauto_alias', $alias, $context);
+
+  // If we have arrived at an empty string, discontinue.
+  if (!drupal_strlen($alias)) {
+    return '';
+  }
+
+  // If the alias already exists, generate a new, hopefully unique, variant.
+  $original_alias = $alias;
+  pathauto_alias_uniquify($alias, $source, $language);
+  if ($original_alias != $alias) {
+    // Alert the user why this happened.
+    _pathauto_verbose(t('The automatically generated alias %original_alias conflicted with an existing alias. Alias changed to %alias.', array(
+      '%original_alias' => $original_alias,
+      '%alias' => $alias,
+    )), $op);
+  }
+
+  return $alias;
+}
+
+/**
  * Implements hook_node_delete().
  */
 function workbench_path_revision_node_delete($node) {
-- 
2.3.2 (Apple Git-55)

